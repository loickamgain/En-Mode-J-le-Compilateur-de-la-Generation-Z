package be.unamur.info.b314.compiler.emj;

import be.unamur.info.b314.compiler.EMJParser;
import be.unamur.info.b314.compiler.emj.MySymbol.AllSymbol;
import be.unamur.info.b314.compiler.emj.MySymbol.TableSymbol;

import java.util.*;

import java.util.ArrayList;

/*
Visitor class for the EMJ language, extending the base visitor class generated by ANTLR
@author : Alix Decrop
@version : 1.0
*/
public class EMJVisitor extends be.unamur.info.b314.compiler.EMJParserBaseVisitor<Object> {

    private EMJErrorLogger errorLogger;

    private int givenName_index;

    private TableSymbol tableSymbol;

    public EMJVisitor() {

        this.errorLogger = new EMJErrorLogger();

        this.tableSymbol = new TableSymbol("global");
    }

    /**
     * Returns the instance of the error logger.
     * @return the error logger used by this visitor.
     */
    public EMJErrorLogger getErrorLogger() {
        return this.errorLogger;
    }


    @Override
    public Object visitMap(EMJParser.MapContext ctx) {

        int lines = Integer.parseInt(ctx.INTEGER(0).getText());
        int cols = Integer.parseInt((ctx.INTEGER(1).getText()));

        int nbElements = ctx.element_carte().size();

        int policeCount = 0;
        int villainCount = 0;
        int motorwayCount = 0;

        // 1) verify the minimum size is 2 * 2

        if (lines <2 || cols <2) {
            this.errorLogger.addError(
                    new EMJError(
                            "mapTooSmall : ","the map should have a minimum size of 2 * 2." +
                            "here we have :" + lines + " x " + cols , ctx.start.getLine()
                    )
            );
        }

        //2) count and make sures the element in the map verifies lines * cols

        if (nbElements != lines*cols){
            this.errorLogger.addError(
                    new EMJError(
                            "MapDimensionMismatch :", "the number of element from the map (" +
                            nbElements + ") does not match " + lines + "x" + cols + " = " +(lines*cols),
                            ctx.start.getLine()

                    )
            );
        }


        // 3) get through all the element of the map to respect de given conditions below
        for (EMJParser.Element_carteContext elementCarteContext : ctx.element_carte()) {

            if (elementCarteContext.POLICE() != null) {
                policeCount++;
            }

            if (elementCarteContext.VILLAIN() != null){
                villainCount ++;
            }

            if (elementCarteContext.MOTORWAY() != null){
                motorwayCount++;
            }

        }

        // 3a) verifies the condition exactly one police car
        if (policeCount == 0) {
            this.errorLogger.addError(
                    new EMJError(
                            "MissingPoliceCar","the map must contain exactly one police car (🚔). " +
                            "nothing found." , ctx.start.getLine()
                    )
            );
        }
        else if (policeCount > 1) {

            this.errorLogger.addError(
                    new EMJError(
                            "TooManyPoliceCars : ","the map must contain exactly one police car (🚔)." +
                            " but we found : " + policeCount, ctx.start.getLine()
                    )
            );
        }

        //3b) check for at least one thief
        if(villainCount < 1) {
            this.errorLogger.addError(
                    new EMJError(
                            "MissingVillain :", "the map must contain at least one thief. ",
                            ctx.start.getLine()
                    )
            );
        }

        //3c) check for at least one passable road

        if(motorwayCount < 1) {
            this.errorLogger.addError(
                    new EMJError(
                            "MissingMotorway","the map must have at least one passable road. ",
                            ctx.start.getLine()
                    )
            );
        }

        return null ;
    }

    @Override
    public String[] visitIntExpr(EMJParser.IntExprContext ctx) {

        System.out.println(">> Entering visitIntExpr: " + ctx.getText());

        // case 1 : if the expression is just a variable( LeftExp)
        if  (ctx.leftExp() != null) {

            String[] visitResult = visitLeftExp(ctx.leftExp());

            if (visitResult == null) {
                // the error has already been log in checkLeftExp
                return null;
            }

            // determine whether the variable type is an "int"

            if (!"int".equals((visitResult[0]))) {
                this.errorLogger.addError((
                        new EMJError(
                                "TypeMismatch", "expecting an int but the variable " +
                                ctx.leftExp().ID().getText() + "has as type " + visitResult[0], ctx.start.getLine()
                        )
                ));
                return null;
            }
            return visitResult;


            // case 2 : if it's an expression with parenthèses
        }
        else if (ctx.LPAR() != null && ctx.RPAR() != null) {
            String[] exprResult = visitIntExpr(ctx.intExpr(0));
            if(exprResult != null){
                return new String[]{"int", "(" + exprResult[1] + ")"};
            }
            return null;


            //case 3 if the expression is an integer
        } else if (ctx.INTEGER() != null) {
            String literal = ctx.INTEGER().getText();
            // 🚩 Added check for leading zeros
            if (literal.startsWith("0") && literal.length() > 1) {
                this.errorLogger.addError(new EMJError(
                        "IntegerFormatError",
                        "Invalid integer format: leading zeros are not allowed in integer literals!",
                        ctx.start.getLine()
                ));
                return null;
            }


            try {
                long longValue = Long.parseLong(literal);

                // 🚩 Vérification des bornes du type int Java
                if (longValue < Integer.MIN_VALUE || longValue > Integer.MAX_VALUE) {
                    this.errorLogger.addError(new EMJError(
                            "IntegerOverflow",
                            "Integer value " + literal + " is out of bounds for type int!",
                            ctx.start.getLine()
                    ));
                    return null;
                }

            } catch (NumberFormatException e) {
                this.errorLogger.addError(new EMJError(
                        "IntegerFormatError",
                        "Invalid integer format: " + literal,
                        ctx.start.getLine()
                ));
                return null;
            }

            return new String[]{"int", literal};
        }
        else if (ctx.MINUS() != null && ctx.intExpr().size() < 2) {
            String[] exprResult = visitIntExpr(ctx.intExpr(0));
            if(exprResult != null){
                return new String[]{"int", "-" + exprResult[1]};
            }
            return null;
        }


        //case 4 binary operations (like  "intExpr + intExpr", "intExpr * intExpr", etc.)
        // case 4 binary operations (like "intExpr + intExpr", "intExpr * intExpr", etc.)
        else if (ctx.op != null && ctx.intExpr().size() == 2) {
            // first evaluate left and right operation
            String[] leftExpr = visitIntExpr(ctx.intExpr(0));
            String[] rightExpr = visitIntExpr(ctx.intExpr(1));

            if (leftExpr == null || rightExpr == null) {
                return null;
            }

            // the 2 sides have to be of type int
            if (!"int".equals(leftExpr[0]) || !"int".equals(rightExpr[0])) {
                this.errorLogger.addError(
                        new EMJError(
                                "TypeMismatch",
                                "Arithmetic operation with non-integer operand.",
                                ctx.start.getLine()
                        )
                );
                return null;
            }

            // 🚩 CHECK FOR DIVISION BY ZERO HERE
            if (ctx.op.getType() == EMJParser.DIV) {
                if ("0".equals(rightExpr[1].trim())) {
                    this.errorLogger.addError(
                            new EMJError(
                                    "ArithmeticError",
                                    "Division by zero detected!",
                                    ctx.start.getLine()
                            )
                    );
                    return null;
                }
            }

            // representation of the expression
            String expressionRepresentation = leftExpr[1] + " " + ctx.op.getText() + " " + rightExpr[1];
            return new String[]{"int", expressionRepresentation};
        }


        // case 5
        else if (ctx.callFunc() != null) {
            String[] funcResult = visitCallFunc(ctx.callFunc());
            if (funcResult == null) {
                return null;
            }
            if (!"int".equals(funcResult[0])) {
                // Important: Ne pas loguer l'erreur ici car l'appel pourrait être valide dans un autre contexte.
                return null;
            }
            return funcResult;
        }






        // if no cases works, return null (ou loguer une erreur indiquant une expression non reconnue)
        else {
            this.errorLogger.addError(
                    new EMJError(
                            "InvalidIntExpr", "unknown Expression" + ctx.getText(),
                            ctx.start.getLine()

                    )
            );
            return null ;
        }
    }


    @Override
    public String[] visitLeftExp(EMJParser.LeftExpContext ctx) {
        String scope = tableSymbol.getCurrentScope();
        AllSymbol symbol = tableSymbol.getSymbolFromID(ctx.ID().getText(), scope);

        System.out.println(">>> Entering visitLeftExp for ID: " + ctx.ID().getText() + ", Scope: " + scope);

        if (symbol == null) {
            System.out.println("❌ Error: Symbol not found.");
            this.errorLogger.addError(
                    new EMJError("UndeclaredIdentifier",
                            "The ID " + ctx.ID().getText() + " has not been declared in the scope " + scope,
                            ctx.start.getLine()
                    )
            );
            return null;
        }

        System.out.println("✅ Symbol found: type=" + symbol.getType() + ", value=" + symbol.getValue());

        String givenName = symbol.getGivenName();
        String type = symbol.getType();
        String value = (symbol.getValue() != null) ? symbol.getValue().toString() : null;

        // Cas d'accès à un élément spécifique du tuple
        if (ctx.UN() != null || ctx.ZERO() != null) {
            if (!type.startsWith("tuple-")) {
                this.errorLogger.addError(
                        new EMJError("TypeMismatch",
                                "Trying to access index of non-tuple type " + type,
                                ctx.start.getLine())
                );
                return null;
            }

            String elementType = getTypeFromTuple(type);
            String index = ctx.UN() != null ? "[1]" : "[0]";
            return new String[]{elementType, givenName + index, value};
        }


        return new String[]{type, givenName, value};
    }


    @Override
    public String visitBool(EMJParser.BoolContext ctx) {
        if (ctx.TRUE() != null){
            return "True";
        }
        else if (ctx.FALSE() != null){
            return "False";
        }
        return null;
    }


    /**
     * defines the type with respect to the parser
     * @param ctx the type context.
     * @return the type as string.
     */
    @Override
    public String visitType(EMJParser.TypeContext ctx) {

        if (ctx.EMOJI_TUPLE_OF() != null && ctx.type_emo().INTEGER_EMOJI() != null ){
            return "tuple-int";
        } else if (ctx.EMOJI_TUPLE_OF() != null  && ctx.type_emo().CHAR_EMOJI() != null) {
            return "tuple-char";
        } else if (ctx.EMOJI_TUPLE_OF() != null && ctx.type_emo().BOOL_EMOJI() != null) {
            return "tuple-bool";
        } else if (ctx.EMOJI_TUPLE_OF() != null && ctx.type_emo().STRING_EMOJI() != null) {
            return "tuple-string";
        }
        else if (ctx.type_emo().INTEGER_EMOJI() != null) {
            return "int" ;
        } else if (ctx.type_emo().CHAR_EMOJI() != null) {
            return "char" ;
        } else if (ctx.type_emo().BOOL_EMOJI() !=null){
            return "bool";
        } else if (ctx.type_emo().STRING_EMOJI() != null){
            return "string";
        }
        return null ;
    }

    @Override
    public String[] visitTuple(EMJParser.TupleContext ctx) {
        if (!ctx.INTEGER().isEmpty()) {
            String int1 = ctx.INTEGER(0).getText();
            String int2 = ctx.INTEGER(1).getText();
            return new String[]{"tuple-int","(" + int1 + "," + int2 + ")"};

        } else if (!ctx.CHAR().isEmpty()) {
            String char1 = ctx.CHAR(0).getText();
            String char2 = ctx.CHAR(1).getText();
            return new String[]{"tuple-char","(" + char1 + "," + char2 + ")"};

        } else if (!ctx.STRING().isEmpty()) {
            String string1 = ctx.STRING(0).getText();
            String string2 = ctx.STRING(1).getText();
            return new String[]{"tuple-string","(" + string1 + "," + string2 + ")"};

        } else if (!ctx.bool().isEmpty()) {
            String bool1 = visitBool(ctx.bool().get(0));
            String bool2 = visitBool(ctx.bool().get(1));
            return new String[]{"tuple-bool","(" + bool1 + "," + bool2 + ")"};
        }
        return null;
    }

    @Override
    public String visitFuncDecl(EMJParser.FuncDeclContext ctx) {
        String returnType = "";
        String returnValue = "";
        String funcName = ctx.ID().getText();

        if (tableSymbol.getTable().containsKey(funcName) &&
                tableSymbol.getTable().get(funcName).getScope().equals(funcName)){
            this.errorLogger.addError(
                    new EMJError("FunctionAlreadyExists", "try using another name différent from " +
                            ctx.ID().getText(), ctx.start.getLine()));
            return null;
        }

        // Determine the function's return type.
        if (ctx.funcType().type() != null) {
            returnType = visitType(ctx.funcType().type());
        } else {
            returnType = "void";
        }

        tableSymbol.enterScope(funcName);
        ArrayList<String> paramsGivenName = visitFuncParams(ctx.funcParams());


        String targetName = "func" + givenName_index;
        givenName_index ++;

        AllSymbol func = new AllSymbol(funcName, returnType,null,funcName, targetName);

        tableSymbol.defSymbol(funcName, func);
        if (paramsGivenName != null) {
            for (String param : paramsGivenName) {
                // add in order the type of  each parameter of the function base on their target name
                func.addParmars(tableSymbol.getSymbolfromGivenName(param).getType());
            }
        }


        // Visit each instruction within the function to collect return values.
        if (ctx.instructions() != null) {
            for (EMJParser.InstructionContext instruction : ctx.instructions().instruction()) {
                visitInstruction(instruction);
            }
        }


        // Check if the return type match with the head type.
        if (ctx.funcReturn().rightExp() != null) {
            String[] visitResult = visitRightExp(ctx.funcReturn().rightExp());
            String valueReturn = visitResult != null ? visitResult[1] : null;
            String valueReturnType =  visitResult != null ? visitResult[0] : null;
            System.out.println("[FUNC DECL] " + funcName + " is supposed to return: " + returnType + " / actually returns: " + valueReturnType);



            func.setValue(valueReturn); // set the value of the function with the return value

            if (!returnType.equals(valueReturnType)) {
                this.errorLogger.addError(new EMJError("The value obtained does not match the function return type", ctx.getText(), ctx.start.getLine()));
                return null;
            }

            //add the function to the table
            tableSymbol.defSymbol(funcName, func);

        } else if (ctx.funcReturn().VOID() != null && returnType.equals("void")) {

            // case of no return value.
            tableSymbol.defSymbol(funcName, func);

        }else{
            this.errorLogger.addError(new EMJError("The value obtained does not match the function return type", ctx.getText(), ctx.start.getLine()));
            return null;
        }

        tableSymbol.exitScope(); // Exit the function's scope.

        return null;
    }

    /**
     * use to retrieve the type when it is a tuple
     */
    public static String getTypeFromTuple(String input) {

        if (input.contains("-")) {
            String[] parts = input.split("-", 2);
            return parts[1];
        } else {
            return "";
        }
    }


    /**
     * visit a functions parmeters and return a list of the type of the parmeters
     * it just a transition for the fonction after this one
     */
    @Override
    public ArrayList<String> visitFuncParams(EMJParser.FuncParamsContext ctx) {
        if (ctx.funcParamsNotEmpty() != null) {
            return visitFuncParamsNotEmpty(ctx.funcParamsNotEmpty());
        } else {
            return  null;
        }
    }

    @Override
    public ArrayList<String> visitFuncParamsNotEmpty(EMJParser.FuncParamsNotEmptyContext ctx) {
        ArrayList<String> params = new ArrayList<>();

        if(ctx.type() != null &&  ctx.ID() !=  null){


            String type = visitType(ctx.type());

            String parm_name = "param" + givenName_index;
            givenName_index++;

            // add the parameter to the symbole table
            tableSymbol.defSymbol(ctx.ID().getText(), type,null,tableSymbol.getCurrentScope(), parm_name);
            params.add(parm_name);

        }


        if (ctx.funcParamsNotEmpty() != null) {
            params.addAll (visitFuncParamsNotEmpty(ctx.funcParamsNotEmpty()));
        }
        return params;
    }

    @Override
    public String[] visitRightExp(EMJParser.RightExpContext ctx) {
        if(ctx.rightExpB()!=null){
            return visitRightExpB(ctx.rightExpB());
        } else if(ctx.boolExp()!=null){
            return visitBoolExp(ctx.boolExp());
        } else {
            return null;
        }
    }

    @Override
    public String[] visitRightExpB(EMJParser.RightExpBContext ctx) {
        if (ctx.callFunc() != null) {
            String[] result = visitCallFunc(ctx.callFunc());
            System.out.println("[LOG] visitRightExpB - callFunc returned: " + Arrays.toString(result));
            return result;
        }
        else if (ctx.intExpr() != null){
            String[] intResult = visitIntExpr(ctx.intExpr());
            if (intResult != null) {
                return new String[]{"int", intResult[1]};
            }
        }
        else if(ctx.CHAR()!=null){
            return new String[]{"char" , ctx.CHAR().getText()};
        }
        else if(ctx.STRING()!=null){
            return new String[]{"string", ctx.STRING().getText()};
        }
        else if(ctx.tuple()!= null){
            return visitTuple(ctx.tuple());
        }
        else if (ctx.leftExp() != null){
            return visitLeftExp(ctx.leftExp());
        }
        return null;
    }


    @Override
    public String[] visitBoolExp(EMJParser.BoolExpContext ctx) {
        if (ctx.LPAR() != null && ctx.RPAR() != null && ctx.boolExp().size()<2) {


            if (ctx.boolExp().get(0).rightExpB() != null){
                return visitRightExpB(ctx.boolExp().get(0).rightExpB());
            }

            // the cas the instruction is a boolean expression between parenthesis
            return new String[]{"bool"," ( " + visitBoolExp(ctx.boolExp().get(0))[1] + " ) "};

        } else if (ctx.COMPARATOR() != null) {
            String[] left = visitBoolExp(ctx.boolExp(0));
            String[] right = visitBoolExp(ctx.boolExp(1));
            String comparator = " "+ ctx.COMPARATOR().getText() + " ";

            if (left != null && right != null && left[0].equals(right[0])){
                return new String[]{"bool",left[1] + comparator + right[1]};
            }
            else{
                this.errorLogger.addError(new EMJError("somethings wrong with the comparason logic. To make a comparason the two entity must have the same type.", ctx.getText(), ctx.start.getLine()));
                return null;
            }


        } else if (ctx.CONNECTOR() != null) {
            String[] left = visitBoolExp(ctx.boolExp(0));
            String[] right = visitBoolExp(ctx.boolExp(1));
            String connector = ctx.CONNECTOR().getText();

            if (left != null && right != null && left[0].contains("bool") && right[0].contains("bool")){
                return new String[]{left[0],left[1] + evaluateConnector(connector) + right[1]};
            }
            else{
                this.errorLogger.addError(new EMJError("somethings wrong with the connector logic! connection is made only between boolean expression.", ctx.getText(), ctx.start.getLine()));
                return null;
            }


        } else if (ctx.NON() != null && ctx.boolExp().size()<2) {
            String[] resultVisit = visitBoolExp(ctx.boolExp().get(0));
            if (resultVisit != null && resultVisit[0].contains("bool")){
                return new String[]{"bool","not " +resultVisit[1]};
            }
            else{
                this.errorLogger.addError(new EMJError("somethings wrong with the negation logic! negation is made only with boolean expression.", ctx.getText(), ctx.start.getLine()));
                return null;
            }

        } else if (ctx.bool() != null) {
            return new String[]{"bool",visitBool(ctx.bool())};
        } else {
            return visitRightExpB(ctx.rightExpB());
        }
    }


    private String evaluateConnector(String connector) {
        switch (connector) {
            case "&&":
                return " and ";
            case "||":
                return " or ";
            default:
                return null;
        }
    }

    @Override
    public String[] visitCallFuncArg(EMJParser.CallFuncArgContext ctx) {
        if (ctx.rightExp() != null) {

            return visitRightExp(ctx.rightExp());
        }
        return null;
    }


    /** visit callFuncArgs
     * @return return a list arguments with their respective types
     */
    @Override
    public List<String[]> visitCallFuncArgs(EMJParser.CallFuncArgsContext ctx) {
        //result { { char , '1'} , {int , 9} , {String, "ok"} }
        List<String[]> arguments = new ArrayList<>();

        for (EMJParser.CallFuncArgContext argCtx : ctx.callFuncArg()) {
            arguments.add(visitCallFuncArg(argCtx));
        }
        return arguments;
    }

    @Override
    public String[] visitCallFunc(EMJParser.CallFuncContext ctx) {
        AllSymbol func = tableSymbol.getSymbolFromID(ctx.ID().getText(), ctx.ID().getText());

        if (func != null) {
            List<String> argumentValues = new ArrayList<>();

            if (ctx.callFuncArgs() != null) {
                List<String[]> arguments = visitCallFuncArgs(ctx.callFuncArgs());
                if (func.getParamList().size() != arguments.size()) {
                    this.errorLogger.addError(new EMJError(
                            "ArgumentCountMismatch",
                            "Expected " + func.getParamList().size() + " args, got " + arguments.size(),
                            ctx.start.getLine()));
                    return null;
                }
                for (int i = 0; i < arguments.size(); i++) {
                    if (!arguments.get(i)[0].equals(func.getParamList().get(i))) {
                        this.errorLogger.addError(new EMJError(
                                "ArgumentTypeMismatch",
                                "Argument " + (i + 1) + " expected type " + func.getParamList().get(i) + ", but got " + arguments.get(i)[0],
                                ctx.start.getLine()));
                        return null;
                    }
                    argumentValues.add(arguments.get(i)[1]);
                }
            } else if (!func.getParamList().isEmpty()) {
                this.errorLogger.addError(new EMJError(
                        "ArgumentCountMismatch",
                        "Expected arguments but none given.",
                        ctx.start.getLine()));
                return null;
            }

            if ("void".equals(func.getType())) {
                this.errorLogger.addError(new EMJError(
                        "InvalidVoidUsage",
                        "Cannot use a void function (" + func.getName() + ") as an expression.",
                        ctx.start.getLine()));
                return null;
            }

            return new String[]{func.getType(), func.getGivenName() + "(" + String.join(", ", argumentValues) + ")"};
        } else {
            this.errorLogger.addError(new EMJError(
                    "UndefinedFunction",
                    "The function name " + ctx.ID().getText() + " does not exist.",
                    ctx.start.getLine()));
            return null;
        }
    }


    @Override
    public String visitVariableExprEmoji(EMJParser.VariableExprEmojiContext ctx) {
        System.out.println("\n--- visitVariableExprEmoji ---");

        String variableID = ctx.ID().getText();
        String currentScope = tableSymbol.getCurrentScope();

        System.out.println("Current Scope: " + currentScope);
        System.out.println("Variable ID: " + variableID);

        String targetName;

        AllSymbol existingSymbol = tableSymbol.getSymbolFromID(variableID, currentScope);
        if (existingSymbol != null) {
            this.errorLogger.addError(
                    new EMJError("The ID already exists in this function", variableID, ctx.start.getLine())
            );
            return null;
        }

        // Nouveau nom unique de variable
        targetName = "var" + givenName_index;
        givenName_index++;
        System.out.println("New variable assigned Target Name: " + targetName);

        String type = visitType(ctx.type());
        System.out.println("Declared Type: " + type);

        if (ctx.rightExp() != null) {
            String[] visitResult = visitRightExp(ctx.rightExp());
            System.out.println("Right Expression Result: " + Arrays.toString(visitResult));

            AllSymbol rightSymbol = null;
            if (ctx.rightExp().rightExpB() != null && ctx.rightExp().rightExpB().leftExp() != null) {
                rightSymbol = tableSymbol.getSymbolFromID(ctx.rightExp().rightExpB().leftExp().ID().getText(), currentScope);
                System.out.println("Right Symbol Retrieved: " + rightSymbol);
            }

            if (rightSymbol != null && rightSymbol.getType().contains("tuple") && rightSymbol.getValue() == null) {
                System.out.println("[LOG] Error: Tuple '" + rightSymbol.getName() + "' not initialized.");
                this.errorLogger.addError(new EMJError("The ID refers to a tuple not initialized.", ctx.getText(), ctx.start.getLine()));
                return null;
            } else if (visitResult != null) {
                String typeRight = visitResult[0];
                String value = visitResult[1];

                System.out.println("Type of Right Expression: " + typeRight);

                if (!type.equals(typeRight)) {
                    System.out.println("[LOG] Expected type: " + type + " / Received type: " + typeRight);
                    System.out.println("[LOG] Error: Type mismatch (Expected: " + type + ", Got: " + typeRight + ")");
                    this.errorLogger.addError(new EMJError("The type does not match with the variable define", variableID, ctx.start.getLine()));
                    return null;
                }

                tableSymbol.defSymbol(variableID, type, value, currentScope, targetName);
                System.out.println("Symbol Defined Successfully in Scope: " + currentScope);
            }
        } else {
            tableSymbol.defSymbol(variableID, type, null, currentScope, targetName);
            System.out.println("Symbol Defined Without Right Expression in Scope: " + currentScope);
        }

        return null;
    }


    @Override
    public String visitInstruction(EMJParser.InstructionContext ctx) {
        System.out.println("--- visitInstruction ---");

        if (ctx.callFunc() != null) {
            String[] visitResult = visitCallFunc(ctx.callFunc());
            System.out.println("visitCallFunc Result: " + Arrays.toString(visitResult));

        } else if (ctx.variableExprEmoji() != null) {
            visitVariableExprEmoji(ctx.variableExprEmoji());

        } else if (ctx.affectInstr() != null) {
            visitAffectInstr(ctx.affectInstr());

        } else if (ctx.ifInstr() != null) {
            visitIfInstr(ctx.ifInstr());

        } else if (ctx.loopInstr() != null) {
            visitLoopInstr(ctx.loopInstr());

        } else if (ctx.preFunc() != null) {
            visitPreFunc(ctx.preFunc());
        }

        return null;
    }


    @Override
    public String visitProgram(EMJParser.ProgramContext ctx) {
        if (ctx.imports() != null && ctx.imports().nom_fichier() != null){

        }

        if (ctx.main()!= null){
            if (ctx.main().funcDecl() != null){
                for (EMJParser.FuncDeclContext function : ctx.main().funcDecl()) {
                    visitFuncDecl(function); // Visit each function declaration.
                }
            }
            tableSymbol.enterScope("main"); // Enter a new scope for the main function.

            if (ctx.main().instruction() != null){
                for (EMJParser.InstructionContext instruction : ctx.main().instruction()){
                    visitInstruction(instruction); // Process each instruction in the main function.
                }
            }

            tableSymbol.exitScope(); // Exit the scope of the main function.
        }
        return null;
    }


    /* ---------------------------------------------------------------------------------- */
    /* ---------------------------------------------------------------------------------- */


    @Override
    public String visitAffectInstr(EMJParser.AffectInstrContext ctx) {
        String currentScope = tableSymbol.getCurrentScope();
        AllSymbol existingId = tableSymbol.getSymbolFromID(ctx.leftExp().ID().getText(), currentScope);

        if (existingId == null) {
            this.errorLogger.addError(new EMJError("the ID does not exist, the value cannot be affected.", ctx.getText(), ctx.start.getLine()));
            return null;
        }

        // Check initialization of tuple before usage
        if (ctx.rightExp().rightExpB() != null
                && ctx.rightExp().rightExpB().leftExp() != null) {

            AllSymbol rightSymbol = tableSymbol.getSymbolFromID(
                    ctx.rightExp().rightExpB().leftExp().ID().getText(),
                    currentScope);

            if (rightSymbol != null && rightSymbol.getType().contains("tuple") && rightSymbol.getValue() == null) {
                this.errorLogger.addError(new EMJError("the ID refer to a tuple not initialized.", ctx.getText(), ctx.start.getLine()));
                return null;
            }
        }

        String[] visitResult = visitRightExp(ctx.rightExp());
        if (visitResult == null) return null;

        String typeExp = visitResult[0];
        String value = visitResult[1];

        // Gestion des affectations vers un élément d’un tuple (ex: [🥰]0️ = "valid")
        if (ctx.leftExp().ZERO() != null || ctx.leftExp().UN() != null) {
            String tupleType = existingId.getType();
            if (!tupleType.startsWith("tuple-")) {
                this.errorLogger.addError(new EMJError("Tentative d'accès à un élément sur une variable non tuple.", ctx.getText(), ctx.start.getLine()));
                return null;
            }

            String expectedType = getTypeFromTuple(tupleType);
            if (!expectedType.equals(typeExp)) {
                this.errorLogger.addError(new EMJError("TypeMismatch", "Type incorrect pour l’élément de tuple : attendu " + expectedType + " mais reçu " + typeExp, ctx.getStart().getLine()));
                return null;
            }
            // Affectation valide vers un élément du tuple
            return null;
        }

        // Cas normal (variable simple ou tuple complet)
        if (!existingId.getType().equals(typeExp)) {
            this.errorLogger.addError(new EMJError("the type for affectation doesn't match. Expected: " + existingId.getType() + ", got: " + typeExp, ctx.getText(), ctx.start.getLine()));
            return null;
        }

        // Affectation valide
        return null;
    }





}

